# PenRoseBlog - 个人博客系统

> **📋 最新更新**: 2025年12月13日 - 全栈架构优化与微服务演进规划

## 项目概述

PenRoseBlog 是一个功能完善的现代化全栈个人博客系统。它不仅具备传统的博客功能（文章发布、评论、分类），还深度集成了 AI 助手、实时消息推送、Live2D 看板娘等前沿特性。项目采用前后端分离架构，容器化部署，具备高可用性和良好的扩展性。

### 核心技术栈

**后端 (Backend)**
- **Framework**: Spring Boot 3.4.0
- **Language**: Java 17
- **Database**: MySQL 8.0 (JPA/Hibernate)
- **Cache**: Redis (缓存、防刷计数、验证码)
- **Message Queue**: RabbitMQ (异步解耦、削峰填谷)
- **Security**: Spring Security + JWT (无状态认证)
- **AI Integration**: Spring AI (对接大模型服务)
- **Tools**: Flyway (数据库迁移), MapStruct (DTO映射), Lombok

**前端 (Frontend)**
- **Framework**: React 18.3.1
- **Build Tool**: Vite 7.1.7
- **Routing**: React Router DOM 7.9.5
- **State Management**: React Context + Hooks
- **UI/UX**: CSS Modules (样式分离), Responsive Design (响应式适配)
- **Editor**: TipTap (富文本), Marked (Markdown渲染)
- **Interaction**: Live2D (看板娘), SSE (实时消息流)

**运维 (DevOps)**
- **Container**: Docker, Docker Compose
- **Server**: Nginx (反向代理, 静态资源托管)
- **Cloud Storage**: Tencent Cloud COS (CDN加速)
- **CI/CD**: Shell Scripts (自动化部署)

## 系统架构

### 1. 分层架构设计 (Backend)
后端严格遵循分层架构原则，确保代码的可维护性与测试性：
- **Controller Layer**: 处理 HTTP 请求，参数校验 (`@Valid`)，统一响应封装 (`ApiResponse`)。不包含业务逻辑。
- **Service Layer**: 核心业务逻辑，事务管理 (`@Transactional`)。
- **Repository Layer**: 数据持久化，基于 Spring Data JPA。
- **Model/DTO**: 实体类与数据传输对象分离，通过 MapStruct 自动转换，避免数据库模型直接暴露。

### 2. 前端架构设计 (Frontend)
前端采用模块化和关注点分离的设计：
- **Pages**: `front/src/pages` - 存放所有路由页面组件。
- **Components**: `front/src/components` - 存放可复用组件，按功能模块分类 (article, blogeditor, common, etc.)。
- **Styles**: `front/src/styles` - **样式与逻辑完全分离**，所有 CSS 文件集中管理，按模块分类。
- **Hooks**: `front/src/hooks` - 自定义 React Hooks，封装状态逻辑。
- **Utils**: `front/src/utils` - 通用工具函数。

### 3. 核心功能模块

#### 🤖 AI 助手 (AI Assistant)
- **智能对话**: 集成 Spring AI，支持与大模型进行实时对话。
- **流式响应**: 前端通过 SSE (`EventSource`) 接收 AI 的流式回复，体验流畅。
- **多模态支持**: 支持发送文本及附件（图片/文件）给 AI 进行分析。

#### 📊 混合式浏览量统计 (Hybrid View Counting)
- **高并发设计**: 浏览请求优先写入 Redis，原子计数 (`INCR`)。
- **防刷机制**: 使用 Redis Set 记录 24 小时内访问过的用户/IP，避免重复计数。
- **数据同步**: 定时任务 (`@Scheduled`) 异步将 Redis 中的增量数据同步回 MySQL，保证数据最终一致性。

#### 🔔 实时消息通知 (Real-time Notifications)
- **多渠道推送**: 支持站内信、点赞、评论、关注等多种通知类型。
- **异步处理**: 耗时操作（如邮件发送）通过 RabbitMQ 异步处理，不阻塞主线程。
- **实时触达**: 客户端通过 SSE 保持长连接，实时接收新消息提醒。

#### 📝 内容创作与管理
- **双模式编辑器**: 支持 Markdown 和富文本 (TipTap) 两种编辑模式。
- **资源管理**: 统一的文件上传接口，支持头像、背景图、文章插图的上传与管理，直传腾讯云 COS。
- **分类与标签**: 灵活的文章分类与标签系统，支持多维度检索。

#### 👤 用户与社交
- **安全认证**: 基于 JWT 的无状态认证，支持 Token 自动刷新。
- **社交互动**: 关注、粉丝、好友申请、私信聊天。
- **个性化**: 自定义头像、个人主页背景、个人简介。

## 部署与运维

### 自动化部署
项目包含完整的自动化部署脚本 (`redeploy.sh`)，支持：
- 一键拉取最新代码
- 自动构建 Docker 镜像
- 平滑重启服务
- 自动清理旧镜像

### 环境配置
- **开发环境**: `application.properties` (本地调试)
- **生产环境**: `application-prod.properties` (Docker部署，通过环境变量注入敏感信息)
- **安全配置**: 敏感密钥（如 DB 密码、JWT Secret）均通过环境变量管理，不硬编码在代码中。

---

## 🚀 微服务化与性能优化规划 (Future Roadmap)

基于 `MICROSERVICES_AND_PERFORMANCE_GUIDE.md`，项目计划进行以下架构演进：

### 1. 微服务拆分 (Microservices Migration)
将单体应用拆分为三个核心微服务，以应对不同模块的扩展需求：

| 服务名称 | 端口 | 职责 | 数据库表 |
| :--- | :--- | :--- | :--- |
| **User Service** | 8081 | 用户注册、登录(JWT)、个人资料、好友关系 | `user`, `user_profile`, `follow`, `friend_request` |
| **Blog Service** | 8082 | 文章发布、浏览、评论、点赞、分类标签 | `blog_post`, `comment`, `category`, `tag` |
| **Notification Service** | 8083 | 站内信、邮件、SSE推送 | `private_message`, `notification` |

**基础设施引入:**
- **Spring Cloud Gateway**: 统一流量入口，负责路由转发 (`/api/user/**`, `/api/blog/**`)、鉴权和限流。
- **OpenFeign**: 服务间同步调用（如博客服务查询用户信息）。
- **RabbitMQ**: 服务间异步解耦（如发布文章后触发通知）。

### 2. 极致性能优化 (Performance Optimization)

#### 静态资源 CDN 加速
- **策略**: 将 `site_assets` (静态图标) 和 `sources` (用户上传) 全部接入腾讯云 CDN。
- **实现**: 前端 `resolveUrl.js` 智能判断，自动替换资源 URL 为 CDN 域名。
- **效果**: 降低服务器带宽压力，提升全球访问速度。

#### 多级缓存体系 (L1 Caffeine + L2 Redis)
- **L1 本地缓存 (Caffeine)**: 拦截高频热点读取（如首页文章列表、全局配置），响应时间微秒级，减少 Redis 网络开销。
- **L2 分布式缓存 (Redis)**: 共享缓存数据，保证多实例间的数据一致性。
- **实现**: 通过 Spring Cache 的 `CacheManager` 组合配置实现透明的多级缓存。

### 3. 实施步骤
1.  **准备阶段**: 搭建 Spring Cloud Gateway，配置 Nacos 或 Eureka (可选，或直接使用 K8s DNS)。
2.  **拆分阶段**: 优先拆分 `Notification Service`，因为它与其他业务耦合度最低；其次拆分 `User Service`。
3.  **优化阶段**: 引入 Caffeine，配置 CDN 回源。
