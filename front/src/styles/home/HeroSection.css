.hero-section {
  position: relative;
  width: 100%;
  height: 100vh;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
  /* Ensure it stays behind other content if needed, or sets the stage */
  z-index: 0; 
}

.hero-background {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  /* Placeholder gradient as requested */
  background: linear-gradient(135deg, #a1c4fd 0%, #c2e9fb 100%);
  z-index: -1;
}

.hero-content {
  text-align: center;
  color: white;
  z-index: 1;
  text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
  /* Optional: Add animation for content appearance */
  animation: fadeIn 1.5s ease-out;
}

.hero-title {
  font-size: 4rem;
  font-weight: 700;
  margin-bottom: 1rem;
}

.hero-subtitle {
  font-size: 1.5rem;
  font-weight: 300;
  opacity: 0.9;
}

/* Cloud effect container */
.hero-clouds {
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 30vh; /* Bottom 1/3 approx */
  z-index: 2;
  pointer-events: none;
  background: linear-gradient(to top, rgba(255,255,255,1) 0%, rgba(255,255,255,0.8) 40%, rgba(255,255,255,0) 100%);
  /* Add a mask or shape to simulate clouds if possible without images */
  /* Using a simple wave/cloud SVG as a mask or background image would be better, 
     but for now, we use a gradient and maybe some CSS shapes or animation */
}

/* Advanced Cloud Effect using CSS Radial Gradients to simulate cloud shapes */
.hero-clouds::before,
.hero-clouds::after {
  content: '';
  position: absolute;
  bottom: 0;
  width: 200%;
  height: 100%;
  background: inherit;
  /* This is a simplified way to create a wavy top edge */
  --cloud-color: #ffffff;
  background: 
    radial-gradient(circle at 50% 100%, var(--cloud-color) 20%, transparent 21%),
    radial-gradient(circle at 60% 110%, var(--cloud-color) 20%, transparent 21%),
    radial-gradient(circle at 40% 110%, var(--cloud-color) 20%, transparent 21%);
  background-size: 100px 100px; /* Adjust size */
  background-repeat: repeat-x;
  opacity: 0.8;
  animation: cloudMove 20s linear infinite;
}

.hero-clouds::after {
  bottom: -20px;
  opacity: 0.6;
  animation: cloudMove 30s linear infinite reverse;
  background-size: 150px 150px;
}

/* Better approach for "Floating Clouds" using a mask or a specific background image pattern 
   Since we don't have the image, we will use a CSS generated cloud-like pattern 
   or just the gradient fade as a base and add some moving "cloud" elements.
*/

/* Let's try a more robust CSS cloud implementation */
.hero-clouds {
    background: transparent; /* Reset base background */
    overflow: hidden;
}

.hero-clouds-layer {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: url('data:image/svg+xml;utf8,<svg viewBox="0 0 1440 320" xmlns="http://www.w3.org/2000/svg"><path fill="%23ffffff" fill-opacity="1" d="M0,224L48,213.3C96,203,192,181,288,181.3C384,181,480,203,576,224C672,245,768,267,864,261.3C960,256,1056,224,1152,208C1248,192,1344,192,1392,192L1440,192L1440,320L1392,320C1344,320,1248,320,1152,320C1056,320,960,320,864,320C768,320,672,320,576,320C480,320,384,320,288,320C192,320,96,320,48,320L0,320Z"></path></svg>');
    background-size: cover;
    background-repeat: no-repeat;
    background-position: bottom;
    /* This is just a wave, not exactly clouds, but close for a start. 
       For "clouds", we might need multiple layers of these with different opacities and animations. */
}

/* Re-implementing .hero-clouds to match the "floating clouds dynamic style" description more closely 
   The user wants "gradient transparency occlusion" (渐变透明度的遮挡).
   This suggests a white gradient at the bottom that fades out upwards, possibly with a cloud texture.
*/
.hero-clouds {
    background: linear-gradient(to top, #ffffff 20%, rgba(255, 255, 255, 0.8) 50%, rgba(255, 255, 255, 0) 100%);
    /* Add animation to simulate movement if desired */
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
}

@keyframes cloudMove {
  0% { transform: translateX(0); }
  100% { transform: translateX(-50%); }
}
